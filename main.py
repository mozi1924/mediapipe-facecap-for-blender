import argparse
import cv2
import mediapipe as mp
import time
import numpy as np
from pathlib import Path
from config.settings import CONFIG
from models.face_utils import calculate_features, draw_preview, MODEL_POINTS
from utils.network import UDPTransmitter
from models.smoother import FeatureSmoother
from utils.calibration import save_calibration
from utils.recording import Recorder
from utils.camera import CameraManager

# ----------------------------
# Parameter parsing module
# ----------------------------
def parse_args():
    parser = argparse.ArgumentParser(description="Mozi's facecap for blender transmitter")
    parser.add_argument('--input', type=str, default='auto', help='Video input source (auto for detection)')
    parser.add_argument('--udp_ip', type=str, default='0.0.0.0', help='UDP Destination IP')
    parser.add_argument('--udp_port', type=int, default=12345, help='UDP port number')
    parser.add_argument('--preview', action='store_true', help='Enable Live Preview')
    parser.add_argument('--no_smooth', action='store_true', help='Disable Smoothing')
    parser.add_argument('--record', action='store_true', help='Enable recording to CSV')
    parser.add_argument('--record_fps', type=float, default=None, help='Recording Frame Rate (Override Config)')
    parser.add_argument('--record_output', type=str, default=None, help='CSV output path (generated by time by default)')
    return parser.parse_args()

# ----------------------------
# Face Detector Class
# ----------------------------
class FaceMeshDetector:
    def __init__(self):
        self.face_mesh = self._init_face_mesh()

    def _init_face_mesh(self):
        """Initialize MediaPipe according to the configuration"""
        return mp.solutions.face_mesh.FaceMesh(
            max_num_faces=1,
            refine_landmarks=True,
            min_detection_confidence=0.5,
            min_tracking_confidence=0.5
        )

    def process(self, frame):
        """Process the frame and return feature points"""
        rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
        return self.face_mesh.process(rgb)

    def close(self):
        self.face_mesh.close()

# ----------------------------
# Main program logic
# ----------------------------
def main():
    args = parse_args()
    
    # Initialize Components
    camera = CameraManager(args.input)
    detector = FaceMeshDetector()
    transmitter = UDPTransmitter(args.udp_ip, args.udp_port)
    smoother = FeatureSmoother() if not args.no_smooth else None
    recorder = None
    if args.record:
        recorder = Recorder(
            output_path=args.record_output,
            fps=args.record_fps
        )

    last_send = 0
    try:
        while True:
            frame = camera.read_frame()
            if frame is None: break

            # Feature Detection
            res = detector.process(frame)
            if not res.multi_face_landmarks: continue

            # Calculate features
            lm = res.multi_face_landmarks[0].landmark
            features = calculate_features(lm, frame.shape)

            # Smoothing
            if smoother:
                features = smoother.apply(features)

            # Send data at configured FPS
            if time.time() - last_send > 1/CONFIG['preview']['fps']:
                transmitter.send(features)
                last_send = time.time()

            if recorder:
                recorder.record(features)

            # Live Preview
            if args.preview:
                preview_img = draw_preview(frame.copy(), features)
                cv2.imshow('Preview', preview_img)
                if cv2.waitKey(1) & 0xFF == 27:  # ESC
                    break
            
            # calibration
            if args.preview:
                preview_img = draw_preview(frame.copy(), features)
                cv2.imshow('Preview', preview_img)
                key = cv2.waitKey(1) & 0xFF
                if key == ord('c'):  # Press the C key to trigger calibration
                    save_calibration(features)  # Call the calibration function
                    
                    


    finally:
        if recorder:
            recorder.close()
        camera.release()
        detector.close()
        transmitter.close()
        cv2.destroyAllWindows()

if __name__ == '__main__':
    main()